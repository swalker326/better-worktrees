# TUI Major Redesign Plan

## Goal
Replace the monolithic `src/tui/App.tsx` with a proper React/OpenTUI architecture built around explicit state transitions, command routing, and focused components. This is a **major redesign** with a **new keymap** (old shortcuts removed), while keeping core product workflows (open repo, browse worktrees, create/delete worktree, repo settings).

## Recommended Architecture
- Use a reducer-driven controller (`useReducer`) with typed events and explicit UI modes.
- Move all async side effects (repo/worktree/settings/autocomplete IO) into a dedicated effect runner.
- Keep `App.tsx` as a composition shell: render layout, connect keyboard input to command routing, and pass view props to components.
- Implement a clear mode model instead of boolean flags:
  - `browse`
  - `openPath`
  - `createWorktree`
  - `confirmDelete`
  - `settingsBrowse`
  - `settingsEditTemplate`
  - `settingsEditRule`
- Replace ad-hoc key handling with a declarative key router and per-mode keymaps.

## Key UX Redesign (Replace Existing Keymap)
- Define a new primary keymap with explicit global + mode-local bindings.
- Remove hard dependency on Vim-style legacy aliases (`h/l`, `j/k`, etc.) and adopt a consistent, discoverable scheme.
- Keep help text fully synced with mode/keymap from selectors so docs cannot drift.
- Preserve `ctrl+c` and renderer cleanup behavior via `renderer.destroy()`.

## Files To Change

### Refactor existing
- `src/tui/App.tsx` (shrink to shell + composition)
- `src/tui/components/RepoSelectPanel.tsx` (prop updates only, if needed)
- `src/tui/components/WorktreeScrollPanel.tsx` (prop updates only, if needed)
- `src/tui/components/StatusFooter.tsx` (show mode-aware help)

### Add new core modules
- `src/tui/state/types.ts` (state/events/effects/contracts)
- `src/tui/state/reducer.ts` (pure transitions)
- `src/tui/state/selectors.ts` (derived view state)
- `src/tui/state/effects.ts` (async effect execution)
- `src/tui/state/useAppController.ts` (controller hook wiring reducer + effects)
- `src/tui/keyboard/bindings.ts` (new keymap tables)
- `src/tui/keyboard/routeKey.ts` (key -> command routing)
- `src/tui/interaction/modeMachine.ts` (mode transition guards)

### Add or repurpose modal components
- `src/tui/components/modals/OpenPathModal.tsx` (new)
- `src/tui/components/CreateWorktreeModal.tsx` (wire into active app)
- `src/tui/components/DeleteConfirmModal.tsx` (wire into active app)
- `src/tui/components/RepoSettingsModal.tsx` (wire into active app)

### Cleanup candidates (after migration)
- `src/tui/screens/RepoPicker.tsx`
- `src/tui/screens/WorktreeList.tsx`

## Implementation Steps
1. **Introduce app state contracts**
   - Add typed state/events/effects and reducer skeleton.
   - Add selectors for `allRepos`, selections, mode labels, status/help strings.

2. **Build command routing and keymap**
   - Define new keymap tables in `keyboard/bindings.ts`.
   - Add `routeKey` to map `useKeyboard` events + mode/focus into app commands.

3. **Move async orchestration out of App**
   - Implement `state/effects.ts` for service calls:
     - repo activation/loading
     - saved repo add/remove
     - worktree refresh/create/delete
     - settings read/update
     - open-path suggestions
   - Add stale-result guards for async suggestion/loading races.

4. **Create `useAppController`**
   - Wire reducer + effect queue + bootstrap sequence (cwd repo fallback behavior as redesigned).
   - Expose view model and dispatch helpers to UI layer.

5. **Restructure App rendering**
   - Replace inline modal JSX with dedicated modal components.
   - Keep OpenTUI text styling via nested tags (no prop-based text modifiers).
   - Ensure help footer reflects new keymap and active mode.

6. **Remove obsolete branches/state**
   - Delete monolithic `useKeyboard` branch tree.
   - Remove old boolean mode flags that are superseded by mode machine.

7. **Clean up unused/legacy screen components**
   - Remove or repurpose only after new flow is fully wired and tested.

## Testing Plan (Required)

### New tests
- `src/tui/state/reducer.test.ts`
  - mode transitions
  - draft reset rules
  - index clamping and selection behavior
  - busy/status state changes

- `src/tui/state/selectors.test.ts`
  - merged repo list behavior
  - selected item derivations
  - mode/help text output

- `src/tui/interaction/modeMachine.test.ts`
  - allowed vs blocked transitions
  - guarded transitions (delete only on non-main worktree, etc.)

- `src/tui/keyboard/routeKey.test.ts`
  - global key precedence
  - per-mode key behavior
  - no-op/unknown key handling

- `src/tui/state/effects.test.ts`
  - success/error paths with mocked service boundaries
  - stale async response protection

- `src/tui/state/useAppController.test.ts`
  - boot flow
  - open path flow
  - create/delete flow
  - settings edit/remove flow

### Existing tests to keep green
- `src/tui/openPathAutocomplete.test.ts`
- `src/tui/pathDisplay.test.ts`

## Verification Checklist
- Run: `bun test`
- Run: `bunx tsc --noEmit`
- Run smoke command: `bun run src/index.tsx --help`
- Run manual TUI smoke: `bun run src/index.tsx`
  - validate new keymap in each mode
  - validate modal transitions
  - validate repo/worktree/settings workflows end-to-end

## Risk Mitigation
- Implement in small commits/steps so failures localize quickly.
- Add tests before deleting old keyboard/state code paths.
- Keep side effects isolated and injectable/mocked for deterministic tests.
- Keep final sweep for unused legacy components only after behavior is covered.

---

## Follow-up: Open Path Autocomplete Hardening

### Goal
Make open-path input feel deterministic and fast:
- Immediate inline completion while typing (e.g. `~/Dev` previews full completion)
- `Tab` accepts/advances completion
- Suggestion list always reflects directories in current input context

### Critical Files
- `src/tui/openPathAutocomplete.ts`
- `src/tui/openPathAutocomplete.test.ts`
- `src/tui/state/types.ts`
- `src/tui/state/reducer.ts`
- `src/tui/state/useAppController.ts`
- `src/tui/components/modals/OpenPathModal.tsx`
- `src/tui/keyboard/routeKey.test.ts`

### Recommended Implementation
1. **Canonicalize path logic in one place**
   - Add a shared input-analysis helper in `openPathAutocomplete.ts` that derives:
     - typed display value (`~` preserved)
     - typed absolute path (for matching)
     - context directory absolute path
     - current leaf prefix
   - Ensure matching/completion always compares canonical absolute paths.

2. **Upgrade suggestion model**
   - Replace `string[]` suggestions with typed entries containing both absolute and display paths.
   - Keep rendering on display paths; keep matching/submission on absolute paths.

3. **Add inline completion state**
   - Extend open-path state with `openInlineCompletion` and stable selected suggestion identity.
   - Stop relying only on `openSuggestionIndex` for selection stability.

4. **Fix open-path interaction rules**
   - On draft change: reset stale selection and recompute inline completion.
   - `Tab`: first accepts inline completion; repeated Tab advances to next suggestion.
   - `Enter`: if a suggestion is explicitly selected, submit it; otherwise submit typed draft.

5. **Make context-directory listing explicit**
   - If input ends with slash, list child directories of that exact directory.
   - Otherwise list/filter entries from the parent context directory.

6. **Controller race-safety**
   - Keep request-id guard for async suggestions and drop stale responses.
   - Reconcile current selection against new suggestions by identity, not stale index.

### Test Plan (Regression-focused)
- In `src/tui/openPathAutocomplete.test.ts` add cases for:
  - `~/Dev` inline completion correctness against `~`-collapsed suggestions
  - trailing-slash child directory listing
  - parent-context prefix filtering
  - Tab accept-then-advance behavior
  - submit precedence (explicit selection vs typed input)
- In `src/tui/state/reducer.test.ts` add open-path state transition checks:
  - draft change resets stale selection
  - suggestion refresh keeps selected identity when present
- In `src/tui/keyboard/routeKey.test.ts` add explicit open-path key mapping assertions (`Tab`, `Up/Down`, `Enter`, `Esc`).

### Verification
- `bun test`
- `bunx tsc --noEmit`
- `bun run src/index.tsx --help`
- `bun run src/index.tsx` and manually validate:
  - typing `~/Dev` immediately previews full completion
  - suggestions list corresponds to current directory context
  - Tab/Enter behavior matches rules above
